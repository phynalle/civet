use std::cell::RefCell;
use std::collections::HashMap;
use std::io;
use std::rc::Rc;

use syntax::Syntax;
use tokenizer::Grammar;

// EXT_LANG_MAP will be generated by buils.js when compile
// process starts over in different file

lazy_static! {
    static ref EXT_LANG_MAP: HashMap<&'static str, &'static str> = {
        let mut m = HashMap::new();
        m.insert("rs", "Rust");
        m.insert("go", "Go");
        m
    };
}

pub fn identify(ext: &str) -> Option<&str> {
    EXT_LANG_MAP.get(ext).cloned()
}

pub struct LangLoader { 
    grammars: RefCell<HashMap<String, Rc<Grammar>>>
}

impl LangLoader {
    pub fn new() -> LangLoader {
        LangLoader { 
            grammars: RefCell::new(HashMap::new()) 
        }
    }

    pub fn load_grammar(&self, lang: &str) -> Rc<Grammar> {
        if let Some(g) = self.grammars.borrow().get(lang) {
            return g.clone();
        }
        match _load_grammar(lang) {
            Ok(g) => {
                let g = Rc::new(g);
                self.grammars.borrow_mut().insert(lang.to_owned(), g.clone());                
                g
            }
            Err(e) => panic!("{}", e),
        } 
    }
}


// it is the following functions starting with _ that will be generated
// by build.js when compile process starts over in different file

fn _load_grammar(lang: &str) -> io::Result<Grammar> {
    match lang {
        "Rust" => _load_rust_grammar(),
        "Go" => _load_go_grammar(),
        _ => panic!("undefined language: {}", lang),
    }
}

fn _load_rust_grammar() -> io::Result<Grammar> {
    let syntax = Syntax::new("syntaxes/rust.json")?;
    Ok(syntax.compact())
}

fn _load_go_grammar() -> io::Result<Grammar> {
    let syntax = Syntax::new("syntaxes/go.json")?;
    Ok(syntax.compact())
}
